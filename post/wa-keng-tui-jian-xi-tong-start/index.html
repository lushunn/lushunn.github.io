<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>《推荐系统实践》读书笔记 第1-2章 | hi~</title>
<meta name="description" content="凡有所相，皆为虚妄
">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://lushunn.github.io/favicon.ico?v=1575902902942">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lushunn.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154126670-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154126670-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://lushunn.github.io">
        <img src="https://lushunn.github.io/images/avatar.png?v=1575902902942" class="site-logo">
        <h1 class="site-title">hi~</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      凡有所相，皆为虚妄

    </div>
    <div class="site-footer">
      Github <a href="https://github.com/lushunn" target="_blank">lushun</a>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154126670-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154126670-1');
</script> | <a class="rss" href="https://lushunn.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">《推荐系统实践》读书笔记 第1-2章</h2>
            <div class="post-date">2019-12-04</div>
            
            <div class="post-content">
              <h1 id="目录">目录</h1>
<!-- TOC -->
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%A5%BD%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">第一章 好的推荐系统</a>
<ul>
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">1.什么是好的推荐系统</a></li>
<li><a href="#2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%B3%95">2.推荐系统实验方法</a></li>
<li><a href="#3%E8%AF%84%E6%B5%8B%E6%8C%87%E6%A0%87">3.评测指标</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE">第二章利用用户行为数据</a>
<ul>
<li><a href="#1%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90">1.用户行为分析</a></li>
<li><a href="#2%E5%9F%BA%E4%BA%8E%E9%82%BB%E5%9F%9F%E7%9A%84%E7%AE%97%E6%B3%95">2.基于邻域的算法</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95">基于用户的协同过滤算法</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E6%94%B9%E8%BF%9B">用户相似度计算的改进</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95">基于物品的协同过滤算法</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%AF%B9%E7%89%A9%E5%93%81%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D">用户活跃度对物品相似度的影响</a></li>
<li><a href="#%E7%89%A9%E5%93%81%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E5%BD%92%E4%B8%80%E5%8C%96">物品相似度的归一化</a></li>
<li><a href="#usercf%E5%92%8Citemcf%E7%9A%84%E7%BB%BC%E5%90%88%E6%AF%94%E8%BE%83">UserCF和ItemCF的综合比较</a></li>
<li><a href="#%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B">隐语义模型</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Elfm%E7%9A%84%E5%AE%9E%E9%99%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%8B%E5%AD%90">基于LFM的实际系统的例子</a></li>
<li><a href="#lfm%E5%92%8C%E5%9F%BA%E4%BA%8E%E9%A2%86%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">LFM和基于领域的方法的比较</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E6%A8%A1%E5%9E%8B">3.基于图的模型</a>
<ul>
<li><a href="#1%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E5%88%86%E5%9B%BE%E8%A1%A8%E7%A4%BA">用户行为数据的二分图表示</a></li>
<li><a href="#2%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95">基于图的推荐算法</a><!-- /TOC --></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第一章-好的推荐系统">第一章 好的推荐系统</h1>
<h2 id="1什么是好的推荐系统">1.什么是好的推荐系统</h2>
<p>好的推荐系统能使用户、物品提供者和提供推荐系统的平台三方达到共赢。<br>
<img src="https://lushunn.github.io/post-images/1575381642094.png" alt=""></p>
<h2 id="2推荐系统实验方法">2.推荐系统实验方法</h2>
<p>在推荐系统中，主要有3种评测推荐效果的实验方法，即离线实验（offline experiment）、用户调（user study）和在线实验（online experiment）。</p>
<ul>
<li>
<p>离线实验<br>
(1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；<br>
(2) 将数据集按照一定的规则分成训练集和测试集；<br>
(3) 在训练集上训练用户兴趣模型，在测试集上进行预测；<br>
<img src="https://lushunn.github.io/post-images/1575382135010.png" alt=""></p>
</li>
<li>
<p>用户调查</p>
</li>
<li>
<p>在线实验<br>
下图是一个简单的AB测试系统。用户进入网站后，流量分配系统决定用户是否需要被进<br>
行AB测试，如果需要的话，流量分配系统会给用户打上在测试中属于什么分组的标签。然后用<br>
户浏览网页，而用户在浏览网页时的行为都会被通过日志系统发回后台的日志数据库。此时，如<br>
果用户有测试分组的标签，那么该标签也会被发回后台数据库。在后台，实验人员的工作首先是<br>
配置流量分配系统，决定满足什么条件的用户参加什么样的测试。其次，实验人员需要统计日志<br>
数据库中的数据，通过评测系统生成不同分组用户的实验报告，并比较和评测实验结果。<br>
<img src="https://lushunn.github.io/post-images/1575382258504.png" alt=""><br>
一般来说，一个新的推荐算法最终上线，需要完成上面所说的3个实验。<br>
1)首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。<br>
2)然后，需要通过用户调查确定它的用户满意度不低于现有的算法。<br>
3)最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法。</p>
</li>
</ul>
<h3 id="3评测指标">3.评测指标</h3>
<p>1)用户满意度<br>
2)预测准确度</p>
<ul>
<li>评分预测<br>
<img src="https://lushunn.github.io/post-images/1575382587613.png" alt=""></li>
<li>TopN推荐<br>
<img src="https://lushunn.github.io/post-images/1575382664978.png" alt=""></li>
<li>覆盖率<br>
覆盖率（coverage）描述一个推荐系统对物品长尾的发掘能力。覆盖率有不同的定义方法，最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例。假设系统的用户集合为U，推荐系统给每个用户推荐一个长度为N的物品列表R(u)<br>
<img src="https://lushunn.github.io/post-images/1575382755052.png" alt=""><br>
覆盖率是一个内容提供商会关心的指标，上面的定义过于粗略。覆盖率为100%的系统可以有无数的物品流行度分布。为了更细致地描述推荐系统发掘长尾的能力，需要统计推荐列表中不同物品出现次数的分布。如果所有的物品都出现在推荐列表中，且出现的次数差不多，那么推荐系统发掘长尾的能力就很好。<br>
<img src="https://lushunn.github.io/post-images/1575383569449.png" alt=""></li>
<li>多样性<br>
<img src="https://lushunn.github.io/post-images/1575383639902.png" alt=""><br>
<img src="https://lushunn.github.io/post-images/1575383644382.png" alt=""></li>
<li>新颖度</li>
<li>惊喜度</li>
<li>信任度</li>
<li>实时性<br>
（1）推荐系统需要实时地更新推荐列表来满足用户新的行为变化。<br>
（2）推荐系统需要能够将新加入系统的物品推荐给用户。</li>
<li>健壮性</li>
</ul>
<p>#第二章利用用户行为数据<br>
基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法<br>
称为协同过滤算法。</p>
<p>用户行为在个性化推荐系统中一般分两种——显性反馈行为（explicit feedback）和隐性反馈<br>
行为（implicit feedback）。显性反馈行为包括用户明确表示对物品喜好的行为。隐性反馈行为指的是那些不能明确反应用户喜好的行为。最具代表性的隐性反馈行为就是页面浏览行为。<br>
<img src="https://lushunn.github.io/post-images/1575384226268.png" alt=""><br>
<img src="https://lushunn.github.io/post-images/1575384235006.png" alt=""></p>
<h2 id="1用户行为分析">1.用户行为分析</h2>
<p>很多关于互联网数据的研究发现，互联网上的很多数据分布都满足一种称为Power Law的分布，这个分布在互联网领域也称长尾分布。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>a</mi><msup><mi>x</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">f(x)=ax^k 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>（1）不管是物品的流行度还是用户的活跃度，都近似于长尾分布。<br>
（2）用户越活跃，越倾向于浏览冷门的物品</p>
<h2 id="2基于邻域的算法">2.基于邻域的算法</h2>
<h3 id="基于用户的协同过滤算法">基于用户的协同过滤算法</h3>
<p>基于用户的协同过滤算法主要包括两个步骤。<br>
(1) 找到和目标用户兴趣相似的用户集合。<br>
<img src="https://lushunn.github.io/post-images/1575385068600.png" alt=""><br>
直接对两两用户都利用余弦相似度计算相似度算法时间复杂度较大，用户数很大时非常耗时。<br>
改进1:</p>
<p>思路：我们可以首先计算出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo><mi>N</mi><mo>(</mo><mi>u</mi><mo>)</mo><mo>⋂</mo><mi>N</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>∣</mo><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mid N(u) \bigcap N(v)\mid \not=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的用户对(u,v)，然后再对这种情况除以分母<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mo>∣</mo><mi>N</mi><mo>(</mo><mi>u</mi><mo>)</mo><mo>⋂</mo><mi>N</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>∣</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{\mid N(u) \bigcap N(v) \mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30500499999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.934995em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span></span><span style="top:-2.894995em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30500499999999997em;"><span></span></span></span></span></span></span></span></span>。<br>
具体实现：<br>
为此，可以首先建立物品到用户的倒排表，对于每个物品都保存对该物品产生过行为的用户<br>
列表。令稀疏矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>v</mi><mo>]</mo><mo>=</mo><mo>∣</mo><mi>N</mi><mo>(</mo><mi>u</mi><mo>)</mo><mo>⋂</mo><mi>N</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>∣</mo></mrow><annotation encoding="application/x-tex">C[u][v]=\mid N(u)\bigcap N(v)\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span></span></span>。那么，假设用户u和用户v同时属于倒排表中K个物品对应的用户列表，就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">C[u][v]=K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。从而，可以扫描倒排表中每个物品对应的用户列表，将用户列<br>
表中的两两用户对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">C[u][v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>加1，最终就可以得到所有用户之间不为0的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">C[u][v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>。<br>
倒排表的生成（物品:a,b,c,d 用户:A,B,C,D）<br>
<img src="https://lushunn.github.io/post-images/1575471780624.png" alt=""></p>
<p>(2) 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。<br>
<img src="https://lushunn.github.io/post-images/1575471908075.png" alt=""></p>
<h3 id="用户相似度计算的改进">用户相似度计算的改进</h3>
<figure data-type="image" tabindex="1"><img src="https://lushunn.github.io/post-images/1575472013099.png" alt=""></figure>
<h3 id="基于物品的协同过滤算法">基于物品的协同过滤算法</h3>
<p>需求：随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空<br>
间复杂度的增长和用户数的增长近似于平方关系。<br>
基于物品的协同过滤算法主要分为两步。<br>
(1) 计算物品之间的相似度。<br>
<img src="https://lushunn.github.io/post-images/1575472496337.png" alt=""></p>
<p><img src="https://lushunn.github.io/post-images/1575472555034.png" alt=""><br>
(2) 根据物品的相似度和用户的历史行为给用户生成推荐列表。<br>
<img src="https://lushunn.github.io/post-images/1575472653595.png" alt=""></p>
<h3 id="用户活跃度对物品相似度的影响">用户活跃度对物品相似度的影响</h3>
<figure data-type="image" tabindex="2"><img src="https://lushunn.github.io/post-images/1575472771304.png" alt=""></figure>
<h3 id="物品相似度的归一化">物品相似度的归一化</h3>
<p>将ItemCF的相似度矩阵按最大值归一化，好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。</p>
<h3 id="usercf和itemcf的综合比较">UserCF和ItemCF的综合比较</h3>
<figure data-type="image" tabindex="3"><img src="https://lushunn.github.io/post-images/1575472925837.png" alt=""></figure>
<ul>
<li>哈利波特问题<br>
<img src="https://lushunn.github.io/post-images/1575473550336.png" alt=""></li>
</ul>
<h3 id="隐语义模型">隐语义模型</h3>
<p>UserCF：首先需要找到和他们看了同样书的其他用户（兴趣相似的用户），然后给他<br>
们推荐那些用户喜欢的其他书。<br>
ItemCF：需要给他们推荐和他们已经看的书相似的书，比如作者B看了很多关于数据<br>
挖掘的书，可以给他推荐机器学习或者模式识别方面的书。<br>
新的算法思路：可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，<br>
然后从分类中挑选他可能喜欢的物品。隐含语义分析技术，因为采取基于用户行为统计的自动聚类，较好的满足了新的算法思路所带来的问题。<br>
<img src="https://lushunn.github.io/post-images/1575473764530.png" alt=""><br>
如何解决隐性反馈数据集上应用LFM解决TopN推荐的没有负样本这个问题：<br>
1.对于一个用户，从他没有过行为的物品中均匀采样出一些物品作为负样本。</p>
<ol>
<li>对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证<br>
每个用户的正负样本数目相当。<br>
3.对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，偏重<br>
采样不热门的物品。<br>
通过2011年的KDD Cup的Yahoo! Music推荐系统比赛的采样方案<br>
1.对每个用户，要保证正负样本的平衡（数目相似）。<br>
2.对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品。</li>
</ol>
<h3 id="基于lfm的实际系统的例子">基于LFM的实际系统的例子</h3>
<figure data-type="image" tabindex="4"><img src="https://lushunn.github.io/post-images/1575474097153.png" alt=""></figure>
<p>遇到的困难：经典的LFM模型每次训练时都需要扫描所有的用户行为记录，这样才能计算出用户隐类向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>p</mi><mi>u</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(p_u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和物品隐类向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>q</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(q_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。LFM的每次训练都很耗时，一般在实际应用中只能每天训练一次，并且计算出所有用户的推荐结果。从而LFM模型不能因为用户行为的变化实时地调整推荐结果来满足用户最近的行为。在新闻推荐中，冷启动问题非常明显。每天都会有大量新的新闻。这些新闻会在很短的时间内获得很多人的关注，但也会在很短的时间内失去用户的关注。因此，它们的生命周期很短，而推荐算法需要在它们短暂的生命周期内就将其推荐给对它们感兴趣的用户。<br>
解决方法：<br>
<img src="https://lushunn.github.io/post-images/1575474302058.png" alt=""></p>
<h3 id="lfm和基于领域的方法的比较">LFM和基于领域的方法的比较</h3>
<p>1)理论基础：LFM具有比较好的理论基础，它是一种学习方法，通过优化一个设定的指标建立最优的模型。基于邻域的方法更多的是一种基于统计的方法，并没有学习过程。<br>
2)离线计算的空间复杂度：基于邻域的方法需要维护一张离线的相关表。在离线计算相关表的过程中，如果用户/物品数很多，将会占据很大的内存。LFM只需占用很少的内存。<br>
3)离线计算的时间复杂度：总体上来说两者没有太大差别。<br>
4)在线实时推荐：UserCF和ItemCF在线服务算法需要将相关表缓存在内存中，然后可以在线进行实时的预测。LFM在给用户生成推荐列表时，需要计算用户对所有物品的兴趣权重，然后排名，返回权重最大的N个物品。那么，在物品数很多时，这一过程的时间复杂度非常高，LFM不太适合用于物品数非常庞大的系统，也不能实时计算。<br>
5)推荐解释：ItemCF算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果。但LFM无法提供这样的解释。</p>
<h3 id="基于图的模型">基于图的模型</h3>
<h4 id="1用户行为数据的二分图表示">1.用户行为数据的二分图表示</h4>
<p>基于图的模型（graph-based model）是推荐系统中的重要内容。用户行为数据是由一系列二元组组成的，其中每个二元组(u, i)表示用户u对物品i产生过行为。这种数据集很容易用一个二分图表示。(用户节点A,B,C和物品节点a、b、c,d)<br>
<img src="https://lushunn.github.io/post-images/1575474753472.png" alt=""></p>
<h4 id="2基于图的推荐算法">2.基于图的推荐算法</h4>
<p>基于上一步，下面的任务就是在二分图上给用户进行个性化推荐。那么给用户u推荐物品的任务就可以转化为度量用户顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">v_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">v_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有边直接相连的物品节点在图上的相关性，相关性越高的物品在推荐列表中的权重就越高。<br>
<img src="https://lushunn.github.io/post-images/1575475124113.png" alt=""></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://lushunn.github.io/tag/1dwTW_nx8" class="tag">
                    机器学习
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://lushunn.github.io/post/c-wk1-xue-xi-bi-ji-mian-xiang-dui-xiang-cheng-xu-she-ji">
                  <h3 class="post-title">
                     C++ wk1学习笔记 面向对象程序设计
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '3a52f974af9281a9e5db',
        clientSecret: 'a277c665ff999c49c800699f4e0782e75f646fad',
        repo: 'lushunn.github.io',
        owner: 'lushunn',
        admin: ['lushunn'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
